// SPDX-FileCopyrightText: Copyright 2025 Carabiner Systems, Inc
// SPDX-License-Identifier: Apache-2.0

syntax = "proto3";
package carabiner.policy.v1;

import "google/protobuf/timestamp.proto";
import "google/protobuf/struct.proto";
import "in_toto_attestation/v1/resource_descriptor.proto";
import "carabiner/signer/v1/identity.proto";

option go_package = "github.com/carabiner-dev/policy/api/v1";

message PolicySet {
    // ID is the policySet identifier
    string id = 1;

    // Meta holds the PolicySet metadata information
    PolicySetMeta meta = 2;

    // Common groups the common data elements to be share by all the
    // policies in the set.
    PolicySetCommon common = 3;

    // Policies is the list of policies grouped in the PolicySet
    repeated Policy policies = 4;

    // Chain is the evidence chain to compute a set of subjects to which
    // all the policies will apply.
    repeated ChainLink chain = 5;

    // PolicyGroup definitions
    repeated PolicyGroup groups = 6;
}

// PolicySetMeta captures data about a policy set.
message PolicySetMeta {
    // Runtime to use as default for policies. Defines the runtime and version
    // to use when evaluating policy code, eg cel/v0
    string runtime = 1;

    // Human description of the PolicySet
    string description = 2;

    // Expiration date. When set, the policyset will fail if the expiration date
    // has passed.
    google.protobuf.Timestamp expiration = 3;

    // Version of the PolicySet.
    int64 version = 4;

    // Enforce marks if the policy engine returns FAIL or SOFTFAIL if policies 
    // fail. Values "ON"/"OFF", defaults to "ON"
    string enforce = 5;

    // Framework references checked by this policy set. The references give 
    // meaning to control references in the policies.
    repeated FrameworkRef frameworks = 6;

    // Origin of the policyset's data, recorded when compiled.
    optional in_toto_attestation.v1.ResourceDescriptor origin = 7;
}

// FrameworkRef is a reference to a security framework. The reference binds
// the controls tested by each the policy to the the framework definition.  
message FrameworkRef {
    // String identifier for the framework
    string id = 1; 
    // Security framework name
    string name = 2; 
    // Link to the framework definition
    in_toto_attestation.v1.ResourceDescriptor definition = 3; 
}

message PolicySetCommon {
    repeated carabiner.signer.v1.Identity identities = 1;
    repeated PolicyRef references = 2;
    map<string, ContextVal> context = 3;
}

message Policy {
    string id = 1;
    PolicyRef source = 2;
    Meta meta = 3;
    map<string, ContextVal> context = 4;
    repeated ChainLink chain = 5;
    repeated carabiner.signer.v1.Identity identities = 6;
    PredicateSpec predicates = 7;
    repeated Transformer transformers = 8;
    repeated Tenet tenets = 9;
}

message PolicyRef {
    string id = 1;
    int64 version = 2;
    carabiner.signer.v1.Identity identity = 3;
    in_toto_attestation.v1.ResourceDescriptor location = 4;
}

message ChainLink {
    oneof source {
        ChainedPredicate predicate = 1;
        // ChainedOutput output = 2;
    };
}

// Meta contains information about the policy itself
message Meta {
    // Runtime identifier. Defines the runtime and version. Eg cel/v0
    string runtime = 1;
    // Human readable description o the policy.
    string description = 2;
    // AssertMode. Controls if one tenet or all must pass for the policy to pass.
    string assert_mode = 3;
    // Control references. Reference to framework controls the policy verifies.
    repeated Control controls = 4; 
    // Version is an integer marking the policy version. Optional.
    int64 version = 5;
    // Enforce controls if a FAILED policy returns FAILED or SOFTFAIL. Values "Y"/"N"
    string enforce = 6;
    // Expiration date. Policies can expire as defined by this optional field.
    optional google.protobuf.Timestamp expiration = 7;
    // Origin captures the origin of a policy when the compiler gathers its data.
    optional in_toto_attestation.v1.ResourceDescriptor origin = 8;
}

// Control is a mapping tying the policy to an framework control
message Control {
    // Control ID string.
    string id = 1;

    // Human readable description of the control
    string title = 2;

    // Framework identifier string
    string framework = 3;

    // Control class/family within its framework
    string class = 4;

    // Subitem identifier of control checks
    string item = 5;
}

// ContextVal defines a contextual value needed by a policy. Context values
// are defined from external sources at runtime and if required will cause the
// policy to fail if unset. 
message ContextVal {
    // Data type of the context value. Enforced values are "string", "int", "bool", "float".
    string type = 1;
    // Required flag. If set to true, policies will not evaluate if the context value is not set.
    optional bool required = 2;
    // Value field. If the ContextVal is typed, the data should be castable to the type defined in Type.
    optional google.protobuf.Value value = 3;
    // Default value when ContextVal is not set. If the ContextVal is typed, the
    // default value should be castable into the type defined in type
    optional google.protobuf.Value default = 4;
    // Human readable description of the ContextValue
    optional string description = 5;
}

// The error structure is returned when a policy is evaluated successfully but 
// the evaluation fails.
message Error {
    // Message contains the condition that failed to be met, causing the policy to fail.
    string message = 1;
    // Guidance is an optional text record that is surfaced to the user with 
    // suggestions to make the policy evaluation pass.
    string guidance = 2;
}

// Este hay que arreglarlo
message Transformer {
    string id = 1;
}

message PredicateSpec {
    repeated string types = 1;
    int32 limit = 2;
}

// Tenet
message Tenet {
    string id = 1;
    string runtime = 2;
    string code = 3;
    PredicateSpec predicates = 4;
    map <string, Output> outputs = 5;
    Error error = 6;
    string title = 7;
    Assessment assessment = 8;
}

message ChainedOutput {
    string policy = 1;
    string tenet = 2; 
}

// ChainedPredicate links a subject to another by extracting data from
// attestations of the first. The spec requires a `selector` to be executed
// by the specified `runtime` on an attestation of type `type`.
//
// The selector exec is expected to return either a hash string or a struct that
// looks like an in-toto resource descriptor which becomes the new effective
// subject during the evaluation.
message ChainedPredicate {
    string type = 1;
    string selector = 2;
    string runtime = 3;
    repeated carabiner.signer.v1.Identity identities = 5;
}

message Assessment {
    string message = 1; 
}

message Output {
    string code = 1;
    google.protobuf.Value value = 2;
}


// PolicyGroup captures the structure of a policy set in a 
message PolicyGroup {
    // Group identifier
    string id = 1;

    // Group metadata
    PolicyGroupMeta meta = 2;

    // Common groups the common data elements to be share by all the
    // policies in the group.
    PolicySetCommon common = 3;

    // Group reference
    PolicyGroupRef source = 4;

    // Policy blocks modeling the group begaviour.
    repeated PolicyBlock blocks = 5;

    // Chain is the evidence chain to compute a set of subjects to which
    // PolicyGroup will apply.
    repeated ChainLink chain = 6;
}

// PolicyBlock groups policies in the PolicySet to apply properties to more 
// than one policy at once.
message PolicyBlock {
    // ID string identifying the block
    string id = 1;

    // Meta contains the metadata describing the 
    PolicyBlockMeta meta = 2;

    // Policies is the list of policies grouped in the block
    repeated Policy policies = 3;
}

// GroupMeta is the metadata definition of a policy group
message PolicyGroupMeta {
    // Description of the policy block
    string description = 1;

    // Version of the group
    int64 version = 2;

    // Control fronted by the policy group
    repeated Control controls = 3;

    // Enforce the block (ON or OFF)
    string enforce = 4;

    // Expiration date of the policy group
    optional google.protobuf.Timestamp expiration = 5;

    // Source of the group data when compiled from remote sources
    optional in_toto_attestation.v1.ResourceDescriptor origin = 6;

    string runtime = 7;
}

// PolicyBlockMeta defines the metadata definition of a policy block
message PolicyBlockMeta {
    // Description of the policy block
    string description = 1;

    // Assert mode to consider the policy block passing (OR or AND)
    string assert_mode = 2;

    // Enforce the block (ON or OFF)
    string enforce = 3;

    // Framework controls fronted by the block
    repeated Control controls = 4;
}

// PolicyGroupRef references a group remotely
message PolicyGroupRef {
    // Group ID    
    string id = 1;

    // Pinned version of the group
    int64 version = 2;

    // Expected identity when the group file is signed
    carabiner.signer.v1.Identity identity = 3;

    // Source location when referenced remotely
    in_toto_attestation.v1.ResourceDescriptor location = 4;
}
